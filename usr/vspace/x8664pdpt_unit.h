/// 2022 Systopia Lab, Computer Science, University of British Columbia. All rights reserved.


// Unit Definitions for `X8664PDPT`

// THIS FILE IS AUTOGENERATED BY THE VELOSIRAPTOR COMPILER



#ifndef X8664PDPT_UNIT_H_
#define X8664PDPT_UNIT_H_ 1


#include <stddef.h>

#include <assert.h>

#include <string.h>

#include "types.h"

#include "consts.h"

#include <myos.h>

#include "x8664pdir_unit.h"

//  --------------------------------- Constants ---------------------------------

// Defined unit constants

// The unit does not define any constants

//  -------------------------------- Constructor --------------------------------

#define x8664pdptentrypage__t MyFrame

enum x8664pdpt_child_kind {
    X8664PDPTENTRYTABLE,
    X8664PDPTENTRYPAGE};

union x8664pdpt_child_union {
    x8664pdir__t x8664pdptentrytable;
    x8664pdptentrypage__t x8664pdptentrypage;
};

/// array element
struct x8664pdpt_child {
    enum x8664pdpt_child_kind kind;
    union x8664pdpt_child_union variants;
};

typedef struct x8664pdpt_child x8664pdpt_child__t;

/// Unit Type `X8664PDPT`
/// @loc: examples/x86_64_pagetable.vrs:383:1
struct x8664pdpt {
    MyVNode vnode;
    x8664pdpt_child__t * children[512];
};

typedef struct x8664pdpt x8664pdpt__t;

/// constructor of the unit type
static inline void x8664pdpt_init(x8664pdpt__t * unit, MyVNode vnode) {
    (unit)->vnode = vnode;
    memset((unit)->children, 0x0, sizeof((unit)->children));
}

//  ----------------------------- Allocate and free ----------------------------

/// allocates memory to hold the in-memory state of the unit
static inline bool x8664pdpt_alloc(x8664pdpt__t * * unit) {
    *(unit) = (x8664pdpt__t *)(os_virt_alloc(sizeof(*(*(unit)))));
    if ((*(unit) == 0x0)) {
        return false;
    }
    // TODO: check for allocation success!
    (*(unit))->vnode = os_vnode_alloc(UnitType_X8664PDPT);
    return true;
}

/// frees memory that holds the in-memory state of the unit
static inline void x8664pdpt_free(x8664pdpt__t * unit) {
    // free up the vnode resources
    os_vnode_free((unit)->vnode);
    // free up the book-keeping data structures
    os_virt_free((uintptr_t)(unit), sizeof(*(unit)));
}

//  ----------------------------- Accessing Children  --------------------------

/// Sets the child pointer of the unit
static inline void x8664pdpt_set_child(x8664pdpt__t * unit, vaddr_t va, x8664pdpt_child__t * dst) {
    size_t idx;
    idx = (va >> 0x1e);
    assert((((unit)->children[idx] == NULL) || (dst == NULL)));
    (unit)->children[idx] = dst;
}

/// Sets the child pointer of the unit
static inline void x8664pdpt_clear_child(x8664pdpt__t * unit, vaddr_t va) {
    x8664pdpt_set_child(unit, va, NULL);
}

/// Gets the child pointer of the unit
static inline x8664pdpt_child__t * x8664pdpt_get_child(x8664pdpt__t * unit, vaddr_t va) {
    assert((va < 0x8000000000));
    // has OS interface, use the data structure instead!
    size_t idx;
    idx = (va >> 0x1e);
    return (unit)->children[idx];
}

//  ---------------------------- Map / Protect/ Unmap ---------------------------

//  --------------------------- Higher Order Functions --------------------------

static inline size_t x8664pdpt_map(x8664pdpt__t * unit, vaddr_t va, size_t sz, flags_t flgs, MyFrame pa) {
    // get the current unit
    x8664pdpt_child__t * child;
    child = x8664pdpt_get_child(unit, va);
    if ((child == NULL)) {
        x8664pdpt_child__t * mapping;
        mapping = (x8664pdpt_child__t *)(os_virt_alloc(sizeof(*(mapping))));
        if ((mapping == NULL)) {
            // couldn't allocate any memory, cannot map!
            return 0x0;
        }
        // Allocate a new table for the mapping
        (mapping)->kind = X8664PDPTENTRYTABLE;
        (((mapping)->variants).x8664pdptentrytable).vnode = os_vnode_alloc(UnitType_X8664PDir);
        // Perform the mapping
        if (errval_to_bool(my_vnode_map(((unit)->vnode).cap, ((((mapping)->variants).x8664pdptentrytable).vnode).cap, va, flgs, 0x0, sz, ((((mapping)->variants).x8664pdptentrytable).vnode).mapping))) {
            // mapping successful: add to bookkeeping
            x8664pdpt_set_child(unit, va, mapping);
            child = mapping;
        } else  {
            // mapping has failed
            os_virt_free((uintptr_t)(mapping), sizeof(*(mapping)));
            return 0x0;
        }
        if ((((sz == 0x40000000) && (va == 0x0)) && ((frame_to_paddr(pa) & 0x3fffffff) == 0x0))) {
            if (errval_to_bool(my_vnode_map(((unit)->vnode).cap, pa.cap, va, flgs, 0x0, sz, pa.mapping))) {
                // mapping successful: add to bookkeeping
                (mapping)->kind = X8664PDPTENTRYPAGE;
                ((mapping)->variants).x8664pdptentrypage = pa;
                x8664pdpt_set_child(unit, va, mapping);
                return 0x40000000;
            } else  {
                os_virt_free((uintptr_t)(mapping), sizeof(*(mapping)));
                return 0x0;
            }
        }
    }
    switch ((child)->kind) {
    case X8664PDPTENTRYTABLE:
    {
        // this is a table mapping, recurse to next unit
        return x8664pdir_map(&(((child)->variants).x8664pdptentrytable), va, sz, flgs, pa);
    }
    break;
    case X8664PDPTENTRYPAGE:
    {
        // there was a frame mapped already, return error
        return 0x0;
    }
    break;
    }
    return 0x0;
}

static inline size_t x8664pdpt_protect(x8664pdpt__t * unit, vaddr_t va, size_t sz, flags_t flgs) {
    // get the current unit
    x8664pdpt_child__t * child;
    child = x8664pdpt_get_child(unit, va);
    if ((child == NULL)) {
        // no mapping here. we can't do protection!
        return 0x0;
    }
    switch ((child)->kind) {
    case X8664PDPTENTRYTABLE:
    {
        // this is a table mapping, recurse to next unit
        return x8664pdir_protect(&(((child)->variants).x8664pdptentrytable), va, sz, flgs);
    }
    break;
    case X8664PDPTENTRYPAGE:
    {
        // this is a frame mapping. check if size matches
        if (((va != 0x0) || (sz != 0x40000000))) {
            return 0x0;
        }
        if (errval_to_bool(my_vnode_modify_flags(((unit)->vnode).cap, va, sz, flgs))) {
            return 0x40000000;
        }
    }
    break;
    }
    return 0x0;
}

static inline size_t x8664pdpt_unmap(x8664pdpt__t * unit, vaddr_t va, size_t sz) {
    // get the current unit
    x8664pdpt_child__t * child;
    child = x8664pdpt_get_child(unit, va);
    if ((child == NULL)) {
        // no mapping here. just return with the size to be unmapped!
        return 0x40000000;
    }
    switch ((child)->kind) {
    case X8664PDPTENTRYTABLE:
    {
        // this is a table mapping, recurse to next unit
        return x8664pdir_unmap(&(((child)->variants).x8664pdptentrytable), va, sz);
    }
    break;
    case X8664PDPTENTRYPAGE:
    {
        // this is a frame mapping. check if size matches
        if (((va != 0x0) || (sz != 0x40000000))) {
            return 0x0;
        }
        if (errval_to_bool(my_vnode_unmap(((unit)->vnode).cap, get_mapping_for_va(va)))) {
            // free up the book-keeping data structures of the frame mapping
            os_virt_free((uintptr_t)(child), sizeof(*(child)));
            return 0x40000000;
        }
    }
    break;
    }
    return 0x0;
}

static inline bool x8664pdpt_resolve(x8664pdpt__t * unit, vaddr_t va, MyFrame * * pa) {
    // resolve through OS spec
    x8664pdpt_child__t * child;
    child = x8664pdpt_get_child(unit, va);
    if ((child == NULL)) {
        return false;
    }
    switch ((child)->kind) {
    case X8664PDPTENTRYTABLE:
    {
        // entry maps an enum -> segment mapping a table
        // segment maps a table, recurse to next unit
        return x8664pdir_resolve(&(((child)->variants).x8664pdptentrytable), va, pa);
    }
    break;
    case X8664PDPTENTRYPAGE:
    {
        // entry maps an enum -> segment mapping a frame
        *(pa) = &(((child)->variants).x8664pdptentrypage);
        return true;
    }
    break;
    }
}

#endif // X8664PDPT_UNIT_H_
