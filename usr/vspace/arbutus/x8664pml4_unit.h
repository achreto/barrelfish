/// 2022 Systopia Lab, Computer Science, University of British Columbia. All rights reserved.


// Unit Definitions for `X8664PML4`

// THIS FILE IS AUTOGENERATED BY THE VELOSIRAPTOR COMPILER



#ifndef X8664PML4_UNIT_H_
#define X8664PML4_UNIT_H_ 1


#include <stddef.h>

#include <assert.h>

#include <string.h>

#include "types.h"

#include "consts.h"

#include <myos.h>

#include "x8664pdpt_unit.h"

//  --------------------------------- Constants ---------------------------------

// Defined unit constants

// The unit does not define any constants

//  -------------------------------- Constructor --------------------------------

#define x8664pml4_child__t x8664pdpt__t

/// Unit Type `X8664PML4`
/// @loc: ../../examples/x86_64_pagetable.vrs:395:1
struct x8664pml4 {
    MyVNode vnode;
    x8664pml4_child__t * children[512];
};

typedef struct x8664pml4 x8664pml4__t;

/// constructor of the unit type
static inline void x8664pml4_init(x8664pml4__t * unit, MyVNode vnode) {
    (unit)->vnode = vnode;
    memset((unit)->children, 0x0, sizeof((unit)->children));
}

//  ----------------------------- Allocate and free ----------------------------

/// allocates memory to hold the in-memory state of the unit
static inline bool x8664pml4_alloc(x8664pml4__t * * unit) {
    *(unit) = (x8664pml4__t *)(os_virt_alloc(sizeof(*(*(unit)))));
    if ((*(unit) == 0x0)) {
        return false;
    }
    // TODO: check for allocation success!
    (*(unit))->vnode = os_vnode_alloc(UnitType_X8664PML4);
    return true;
}

/// frees memory that holds the in-memory state of the unit
static inline void x8664pml4_free(x8664pml4__t * unit) {
    // free up the vnode resources
    os_vnode_free((unit)->vnode);
    // free up the book-keeping data structures
    os_virt_free((uintptr_t)(unit), sizeof(*(unit)));
}

//  ----------------------------- Accessing Children  --------------------------

/// Sets the child pointer of the unit
static inline void x8664pml4_set_child(x8664pml4__t * unit, vaddr_t va, x8664pml4_child__t * dst) {
    size_t idx;
    idx = (va >> 0x27);
    assert((((unit)->children[idx] == NULL) || (dst == NULL)));
    (unit)->children[idx] = dst;
}

/// Sets the child pointer of the unit
static inline void x8664pml4_clear_child(x8664pml4__t * unit, vaddr_t va) {
    x8664pml4_set_child(unit, va, NULL);
}

/// Gets the child pointer of the unit
static inline x8664pml4_child__t * x8664pml4_get_child(x8664pml4__t * unit, vaddr_t va) {
    assert((va < 0x1000000000000));
    // has OS interface, use the data structure instead!
    size_t idx;
    idx = (va >> 0x27);
    return (unit)->children[idx];
}

//  ---------------------------- Map / Protect/ Unmap ---------------------------

//  --------------------------- Higher Order Functions --------------------------

/// Entry: Segment mapping a descriptor (with OSSpec)
static inline size_t x8664pml4_map(x8664pml4__t * unit, vaddr_t va, size_t sz, flags_t flgs, MyFrame pa) {
    // get the current unit
    x8664pml4_child__t * child;
    child = x8664pml4_get_child(unit, va);
    if ((child == NULL)) {
        // no mapping, allocate a new table
        x8664pdpt__t * new_table;
        if (!(x8664pdpt_alloc(&(new_table)))) {
            // couldn't allocate any memory, cannot map!
            return 0x0;
        }
        if (!(errval_to_bool(my_vnode_map(((unit)->vnode).cap, ((new_table)->vnode).cap, va, flgs, 0x0, 0x8000000000, ((new_table)->vnode).mapping)))) {
            // mapping failed, clean up allocation
            x8664pdpt_free(new_table);
            return 0x0;
        }
        x8664pml4_set_child(unit, va, new_table);
        child = new_table;
    }
    return x8664pdpt_map(child, (va & 0x7fffffffff), sz, flgs, pa);
}

/// Entry: Segment mapping a descriptor (with OSSpec)
static inline size_t x8664pml4_protect(x8664pml4__t * unit, vaddr_t va, size_t sz, flags_t flgs) {
    // get the current unit
    x8664pml4_child__t * child;
    child = x8664pml4_get_child(unit, va);
    if ((child == NULL)) {
        // no mapping here. we can't protect. this is an error
        return 0x0;
    }
    return x8664pdpt_protect(child, (va & 0x7fffffffff), sz, flgs);
}

/// Entry: Segment mapping a descriptor (with OSSpec)
static inline size_t x8664pml4_unmap(x8664pml4__t * unit, vaddr_t va, size_t sz) {
    // get the current unit
    x8664pml4_child__t * child;
    child = x8664pml4_get_child(unit, va);
    if ((child == NULL)) {
        // no mapping here. just return with the size to be unmapped!
        return sz;
    }
    return x8664pdpt_unmap(child, (va & 0x7fffffffff), sz);
}

static inline bool x8664pml4_resolve(x8664pml4__t * unit, vaddr_t va, MyFrame * * pa) {
    // resolve through OS spec
    x8664pml4_child__t * child;
    child = x8664pml4_get_child(unit, va);
    if ((child == NULL)) {
        return false;
    }
    // segment maps a table, recurse to next unit
    return x8664pdpt_resolve(child, va, pa);
}

#endif // X8664PML4_UNIT_H_
