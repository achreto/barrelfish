/// 2022 Systopia Lab, Computer Science, University of British Columbia. All rights reserved.


// Unit Definitions for `X86MMU`

// THIS FILE IS AUTOGENERATED BY THE VELOSIRAPTOR COMPILER



#ifndef X86MMU_UNIT_H_
#define X86MMU_UNIT_H_ 1


#include <stddef.h>

#include <assert.h>

#include <string.h>

#include <myos.h>

#include "x8664pml4_unit.h"

#include "consts.h"

#include "types.h"

//  --------------------------- Constants / Constructor -------------------------

// The unit does not define any constants

/// Unit Type `X86MMU`
/// @loc: examples/x86_64_pagetable.vrs:426:1
struct x86mmu {
    MyVNode vnode;
    x8664pml4__t * child;
};

typedef struct x86mmu x86mmu__t;

/// constructor of the unit type
static inline void x86mmu_init(x86mmu__t * unit, x8664pml4__t * child) {
    memset(unit, 0x0, sizeof(*(unit)));
    (unit)->child = child;
}

//  ----------------------------- Allocate and free ----------------------------

// no memory state, cannot allocate

// no memory state, cannot allocate

//  ----------------------------- Address Translation  --------------------------

/// Returns true if the mapping is valid
static inline bool x86mmu_is_valid(x86mmu__t * unit) {
    return ((unit)->child != NULL);
}

/// Sets the child pointer of the unit
static inline void x86mmu_set_child(x86mmu__t * unit, vaddr_t va, x8664pml4__t * dst) {
    (unit)->child = dst;
}

/// Sets the child pointer of the unit
static inline void x86mmu_clear_child(x86mmu__t * unit, vaddr_t va) {
    x86mmu_set_child(unit, va, NULL);
}

/// Gets the child pointer of the unit
static inline x8664pml4__t * x86mmu_get_child(x86mmu__t * unit, vaddr_t va) {
    return (unit)->child;
}

//  ---------------------------- Map / Protect/ Unmap ---------------------------

/// Performs the synth fn map(va: vaddr, sz: size, flgs: flags, pa: X8664PML4) -> ()
///   requires sz == 0x1000000000000;
///   requires va == 0x0;
///   requires (pa & 0xfff) == 0x0; operation on the unit
static inline size_t __x86mmu_do_map(x86mmu__t * unit, vaddr_t va, size_t sz, flags_t flgs, x8664pml4__t * pa) {
    // requires sz == 0x1000000000000
    if (!((sz == 0x1000000000000))) {
        return 0x0;
    }
    // requires va == 0x0
    if (!((va == 0x0))) {
        return 0x0;
    }
    // requires (pa & 0xfff) == 0x0
    if (!(((0x0 & 0xfff) == 0x0))) {
        return 0x0;
    }
    if (errval_to_bool(my_vnode_map(((unit)->vnode).cap, ((pa)->vnode).cap, va, flgs, 0x0, sz, ((pa)->vnode).mapping))) {
        x86mmu_set_child(unit, va, pa);
        return sz;
    } else  {
        return 0x0;
    }
}

/// Performs the synth fn unmap(va: vaddr, sz: size) -> ()
///   requires true; operation on the unit
static inline size_t __x86mmu_do_unmap(x86mmu__t * unit, vaddr_t va, size_t sz) {
    if (errval_to_bool(my_vnode_unmap(((unit)->vnode).cap, get_mapping_for_va(va)))) {
        x86mmu_clear_child(unit, va);
        return sz;
    } else  {
        return 0x0;
    }
}

/// Performs the synth fn protect(va: vaddr, sz: size, flgs: flags) -> ()
///   requires true; operation on the unit
static inline size_t __x86mmu_do_protect(x86mmu__t * unit, vaddr_t va, size_t sz, flags_t flgs) {
    if (errval_to_bool(my_vnode_modify_flags(((unit)->vnode).cap, va, sz, flgs))) {
        return sz;
    } else  {
        return 0x0;
    }
}

//  --------------------------- Higher Order Functions --------------------------

/// Higher-order map function
static inline size_t x86mmu_map(x86mmu__t * unit, vaddr_t va, size_t sz, flags_t flgs, MyFrame pa) {
    if (!(x86mmu_is_valid(unit))) {
        // Allocate the next-level structure
        x8664pml4_alloc(&((unit)->child));
        if (((unit)->child == NULL)) {
            return 0x0;
        }
        // TODO: Map new child child
        if ((__x86mmu_do_map(unit, 0x0, 0x1000000000000, DEFAULT_FLAGS, (unit)->child) == 0x0)) {
            return 0x0;
        }
    }
    return x8664pml4_map((unit)->child, va, sz, flgs, pa);
}

/// Higher-order protect function
static inline size_t x86mmu_protect(x86mmu__t * unit, vaddr_t va, size_t sz, flags_t flgs) {
    if (!(x86mmu_is_valid(unit))) {
        return 0x0;
    }
    x8664pml4__t * next_unit;
    next_unit = x86mmu_get_child(unit, 0x0);
    return x8664pml4_protect(next_unit, va, sz, flgs);
}

/// Higher-order unmap function
static inline size_t x86mmu_unmap(x86mmu__t * unit, vaddr_t va, size_t sz) {
    if (!(x86mmu_is_valid(unit))) {
        return 0x0;
    }
    x8664pml4__t * next_unit;
    next_unit = x86mmu_get_child(unit, 0x0);
    return x8664pml4_unmap(next_unit, va, sz);
}

static inline bool x86mmu_resolve(x86mmu__t * unit, vaddr_t va, MyFrame * * pa) {
    if (!(x86mmu_is_valid(unit))) {
        return false;
    }
    return x8664pml4_resolve((unit)->child, va, pa);
}

#endif // X86MMU_UNIT_H_
