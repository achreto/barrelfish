/// 2022 Systopia Lab, Computer Science, University of British Columbia. All rights reserved.


// Unit Definitions for `X8664PageTable`

// THIS FILE IS AUTOGENERATED BY THE VELOSIRAPTOR COMPILER



#ifndef X8664PAGETABLE_UNIT_H_
#define X8664PAGETABLE_UNIT_H_ 1


#include <stddef.h>

#include <assert.h>

#include <string.h>

#include "types.h"

#include "consts.h"

#include <myos.h>

//  --------------------------------- Constants ---------------------------------

// Defined unit constants

// The unit does not define any constants

//  -------------------------------- Constructor --------------------------------

#define x8664pagetable_child__t MyFrame

/// Unit Type `X8664PageTable`
/// @loc: examples/x86_64_pagetable.vrs:174:1
struct x8664pagetable {
    MyVNode vnode;
    x8664pagetable_child__t * children[512];
};

typedef struct x8664pagetable x8664pagetable__t;

/// constructor of the unit type
static inline void x8664pagetable_init(x8664pagetable__t * unit, MyVNode vnode) {
    (unit)->vnode = vnode;
    memset((unit)->children, 0x0, sizeof((unit)->children));
}

//  ----------------------------- Allocate and free ----------------------------

/// allocates memory to hold the in-memory state of the unit
static inline bool x8664pagetable_alloc(x8664pagetable__t * * unit) {
    *(unit) = (x8664pagetable__t *)(os_virt_alloc(sizeof(*(*(unit)))));
    if ((*(unit) == 0x0)) {
        return false;
    }
    // TODO: check for allocation success!
    (*(unit))->vnode = os_vnode_alloc(UnitType_X8664PageTable);
    return true;
}

/// frees memory that holds the in-memory state of the unit
static inline void x8664pagetable_free(x8664pagetable__t * unit) {
    // free up the vnode resources
    os_vnode_free((unit)->vnode);
    // free up the book-keeping data structures
    os_virt_free((uintptr_t)(unit), sizeof(*(unit)));
}

//  ----------------------------- Accessing Children  --------------------------

/// Sets the child pointer of the unit
static inline void x8664pagetable_set_child(x8664pagetable__t * unit, vaddr_t va, x8664pagetable_child__t * dst) {
    size_t idx;
    idx = (va >> 0xc);
    assert((((unit)->children[idx] == NULL) || (dst == NULL)));
    (unit)->children[idx] = dst;
}

/// Sets the child pointer of the unit
static inline void x8664pagetable_clear_child(x8664pagetable__t * unit, vaddr_t va) {
    x8664pagetable_set_child(unit, va, NULL);
}

/// Gets the child pointer of the unit
static inline x8664pagetable_child__t * x8664pagetable_get_child(x8664pagetable__t * unit, vaddr_t va) {
    assert((va < 0x200000));
    // has OS interface, use the data structure instead!
    size_t idx;
    idx = (va >> 0xc);
    return (unit)->children[idx];
}

//  ---------------------------- Map / Protect/ Unmap ---------------------------

//  --------------------------- Higher Order Functions --------------------------

/// Entry: Segment mapping a frame (with OSSpec)
static inline size_t x8664pagetable_map(x8664pagetable__t * unit, vaddr_t va, size_t sz, flags_t flgs, MyFrame pa) {
    // get the current unit
    x8664pagetable_child__t * child;
    child = x8664pagetable_get_child(unit, va);
    if ((child != NULL)) {
        // already a mapping here! this is an error, return 0
        return 0x0;
    }
    x8664pagetable_child__t * mapping;
    mapping = (x8664pagetable_child__t *)(os_virt_alloc(sizeof(*(mapping))));
    if ((mapping == NULL)) {
        return 0x0;
    }
    if (errval_to_bool(my_vnode_map(((unit)->vnode).cap, pa.cap, va, flgs, 0x0, sz, pa.mapping))) {
        // mapping successful: add to bookkeeping
        *(mapping) = pa;
        x8664pagetable_set_child(unit, va, mapping);
        return 0x1000;
    } else  {
        // mapping failed: clean up bookkeeping
        os_virt_free((uintptr_t)(mapping), sizeof(*(mapping)));
        return 0x0;
    }
}

/// Entry: Segment mapping a frame (with OSSpec)
static inline size_t x8664pagetable_protect(x8664pagetable__t * unit, vaddr_t va, size_t sz, flags_t flgs) {
    // get the current unit
    x8664pagetable_child__t * child;
    child = x8664pagetable_get_child(unit, va);
    if (errval_to_bool(my_vnode_modify_flags(((unit)->vnode).cap, va, sz, flgs))) {
        // protect successful: do-nothing. return success.
        return 0x1000;
    } else  {
        return 0x0;
    }
}

/// Entry: Segment mapping a frame (with OSSpec)
static inline size_t x8664pagetable_unmap(x8664pagetable__t * unit, vaddr_t va, size_t sz) {
    // get the current unit
    x8664pagetable_child__t * child;
    child = x8664pagetable_get_child(unit, va);
    if (errval_to_bool(my_vnode_unmap(((unit)->vnode).cap, get_mapping_for_va(va)))) {
        // unmapping successful: remove from bookkeeping
        x8664pagetable_clear_child(unit, va);
        // free bookkeeping structure
        os_virt_free((uintptr_t)(child), sizeof(*(child)));
        return 0x1000;
    } else  {
        return 0x0;
    }
}

static inline bool x8664pagetable_resolve(x8664pagetable__t * unit, vaddr_t va, MyFrame * * pa) {
    // resolve through OS spec
    x8664pagetable_child__t * child;
    child = x8664pagetable_get_child(unit, va);
    if ((child == NULL)) {
        return false;
    }
    // segment maps a frame, return it!
    *(pa) = child;
    return true;
}

#endif // X8664PAGETABLE_UNIT_H_
